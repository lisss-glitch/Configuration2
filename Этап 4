import csv
import sys
import os
import collections


class DependencyGraph:
    """Класс для представления графа зависимостей"""

    def __init__(self):
        self.graph = collections.defaultdict(list)
        self.cycles = []
        self.all_packages = set()

    def build_from_file(self, file_path):
        """Строит граф из файла зависимостей"""
        if not os.path.exists(file_path):
            print(f"Ошибка: Файл '{file_path}' не найден!")
            return False

        print(f"Анализируем файл {file_path}...")

        try:
            with open(file_path, 'r', encoding='utf-8') as file:
                for line_num, line in enumerate(file, 1):
                    line = line.strip()
                    if not line or line.startswith('#'):
                        continue

                    # Обрабатываем форматы: A: B, C или A -> B, C
                    if ':' in line:
                        parts = line.split(':', 1)
                    elif '->' in line:
                        parts = line.split('->', 1)
                    else:
                        continue

                    if len(parts) != 2:
                        print(f"Предупреждение: Неверный формат в строке {line_num}: {line}")
                        continue

                    package = parts[0].strip()
                    deps_str = parts[1].strip()

                    # Проверяем валидность имени пакета
                    if not self._is_valid_package_name(package):
                        print(f"Предупреждение: Неверное имя пакета в строке {line_num}: {package}")
                        continue

                    self.all_packages.add(package)

                    # Обрабатываем зависимости
                    dep_list = []
                    if deps_str:
                        for dep in deps_str.split(','):
                            dep = dep.strip()
                            if dep and self._is_valid_package_name(dep):
                                dep_list.append(dep)
                                self.all_packages.add(dep)

                    self.graph[package] = dep_list

            # Добавляем пакеты без зависимостей в граф
            for package in self.all_packages:
                if package not in self.graph:
                    self.graph[package] = []

            print(f"Успешно загружено пакетов: {len(self.all_packages)}")
            return True

        except Exception as e:
            print(f"Ошибка при чтении файла: {e}")
            return False

    def _is_valid_package_name(self, name):
        """Проверяет что имя пакета состоит из заглавных латинских букв"""
        return name.isalpha() and name.isupper()

    def get_load_order(self, package_name):
        """
        Возвращает порядок загрузки зависимостей для заданного пакета
        используя алгоритм топологической сортировки (Kahn's algorithm)
        """
        if package_name not in self.all_packages:
            print(f"Пакет '{package_name}' не найден в графе!")
            return None

        # Получаем все узлы, достижимые из package_name
        nodes = set()
        stack = [package_name]
        while stack:
            node = stack.pop()
            if node not in nodes:
                nodes.add(node)
                for dep in self.graph.get(node, []):
                    if dep not in nodes:
                        stack.append(dep)

        # Строим обратный граф для подграфа
        reverse_graph = collections.defaultdict(list)
        for node in nodes:
            for dep in self.graph.get(node, []):
                if dep in nodes:
                    reverse_graph[dep].append(node)

        # Вычисляем входящие степени
        in_degree = {node: 0 for node in nodes}
        for node in nodes:
            for dep in self.graph.get(node, []):
                if dep in nodes:
                    in_degree[dep] += 1

        # Алгоритм Кана для топологической сортировки
        queue = collections.deque()
        for node in nodes:
            if in_degree[node] == 0:
                queue.append(node)

        load_order = []
        while queue:
            node = queue.popleft()
            load_order.append(node)
            for neighbor in reverse_graph.get(node, []):
                in_degree[neighbor] -= 1
                if in_degree[neighbor] == 0:
                    queue.append(neighbor)

        if len(load_order) != len(nodes):
            print("Обнаружены циклические зависимости! Невозможно определить порядок загрузки.")
            return None

        return load_order

    def print_load_order_analysis(self, package_name):
        """Выводит полный анализ порядка загрузки для заданного пакета"""
        print("\n" + "=" * 60)
        print(f"АНАЛИЗ ПОРЯДКА ЗАГРУЗКИ ДЛЯ ПАКЕТА: {package_name}")
        print("=" * 60)

        # Получаем порядок загрузки
        load_order = self.get_load_order(package_name)

        if load_order is None:
            return False

        print(f"Найдено зависимостей для '{package_name}': {len(load_order)} пакетов")

        # Выводим порядок загрузки
        print("\nПОРЯДОК ЗАГРУЗКИ ЗАВИСИМОСТЕЙ:")
        print("-" * 40)
        for i, package in enumerate(load_order, 1):
            print(f"   {i}. {package}")

        # Объяснение порядка
        print("\nОБЪЯСНЕНИЕ ПОРЯДКА:")
        print("-" * 40)
        print("Порядок основан на топологической сортировке графа зависимостей.")
        print("Каждый пакет загружается после всех своих зависимостей.")
        print("Это гарантирует, что при загрузке пакета все его зависимости уже доступны.")

        # Сравнение с реальными менеджерами пакетов
        print("\nСРАВНЕНИЕ С РЕАЛЬНЫМИ МЕНЕДЖЕРАМИ ПАКЕТОВ:")
        print("-" * 40)
        print("В реальных менеджерах пакетов могут быть расхождения из-за:")
        print("  1. Учета версий зависимостей")
        print("  2. Разрешения конфликтов версий")
        print("  3. Оптимизации для параллельной загрузки")
        print("  4. Учета дополнительных метаданных пакетов")
        print("  5. Поддержки альтернативных зависимостей")
        print("  6. Кэширования уже загруженных пакетов")

        print("\nВЕРОЯТНЫЕ РАСХОЖДЕНИЯ:")
        print("-" * 40)
        print("Cargo (Rust): Может объединять одинаковые версии зависимостей")
        print("npm (Node.js): Использует плоскую структуру node_modules")
        print("pip (Python): Учитывает совместимость версий Python")
        print("Maven (Java): Учитывает scope зависимостей (compile/test/runtime)")

        return True


def main():
    """Основная функция программы"""
    if len(sys.argv) != 2:
        print("Использование: python config4.py <конфигурационный_файл.csv>")
        print("   Пример: python config4.py configuration4_simple.csv")
        sys.exit(1)

    config_file = sys.argv[1]

    if not os.path.exists(config_file):
        print(f"Конфигурационный файл '{config_file}' не найден!")
        sys.exit(1)

    print("ЗАПУСК ЭТАПА 4: АНАЛИЗ ПОРЯДКА ЗАГРУЗКИ ЗАВИСИМОСТЕЙ")
    print("=" * 60)

    # Чтение конфигурации
    config = {}
    try:
        with open(config_file, 'r', encoding='utf-8') as file:
            reader = csv.reader(file)
            for row in reader:
                if not row or len(row) < 2 or row[0].strip().startswith('#'):
                    continue
                param_name = row[0].strip()
                param_value = row[1].strip()
                config[param_name] = param_value
    except Exception as e:
        print(f"Ошибка чтения конфигурационного файла: {e}")
        sys.exit(1)

    # Проверка обязательных параметров
    required_params = ["package_name", "repository_url", "test_repo_mode"]
    missing_params = [param for param in required_params if param not in config]
    if missing_params:
        print(f"Отсутствуют обязательные параметры: {', '.join(missing_params)}")
        sys.exit(1)

    package_name = config.get("package_name")
    repository_url = config.get("repository_url")
    test_repo_mode = config.get("test_repo_mode")

    if test_repo_mode.lower() != "true":
        print("Этап 4 требует test_repo_mode=true")
        sys.exit(1)

    print("ПАРАМЕТРЫ КОНФИГУРАЦИИ:")
    print(f"   Пакет для анализа: {package_name}")
    print(f"   Файл зависимостей: {repository_url}")
    print(f"   Режим тестирования: {test_repo_mode}")

    # Построение графа
    print("\nПОСТРОЕНИЕ ГРАФА ЗАВИСИМОСТЕЙ...")
    graph = DependencyGraph()

    if not graph.build_from_file(repository_url):
        print(f"Ошибка построения графа из файла: {repository_url}")
        sys.exit(1)

    # Анализ порядка загрузки
    success = graph.print_load_order_analysis(package_name)

    if success:
        print("\nАНАЛИЗ ЗАВЕРШЕН УСПЕШНО!")
    else:
        print("\nАНАЛИЗ ЗАВЕРШЕН С ОШИБКАМИ!")
        sys.exit(1)


if __name__ == "__main__":
    main()
