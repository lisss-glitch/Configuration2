# Импорт модуля для обработки аргументов командной строки
import argparse
# Импорт системного модуля для работы с системными функциями
import sys


# Основной класс ядра приложения
class ApplicationCore:
    """Ядро приложения"""

    # Конструктор класса
    def __init__(self):
        # Импорт парсера конфигурации (импорт внутри метода для избежания циклических зависимостей)
        from config import ConfigurationParser
        # Создание экземпляра парсера конфигурации
        self.parser = ConfigurationParser()
        # Инициализация переменной для хранения настроек (пока пустая)
        self.settings = None

    # Метод для обработки аргументов командной строки
    def process_arguments(self):
        """Обрабатывает аргументы командной строки"""
        # Создание парсера аргументов с описанием
        argument_parser = argparse.ArgumentParser(
            description='Система анализа зависимостей пакетов'
        )

        # Добавление аргумента для указания файла настроек
        argument_parser.add_argument(
            '--settings-file',  # Имя аргумента в командной строке
            dest='config',  # Имя атрибута в объекте результатов
            default='config.csv',  # Значение по умолчанию
            help='Путь к файлу настроек'  # Текст справки
        )

        # Добавление флага для режима проверки
        argument_parser.add_argument(
            '--verify',  # Имя флага
            action='store_true',  # Действие - установить True при наличии флага
            help='Проверить настройки без выполнения'  # Текст справки
        )

        # Парсинг аргументов командной строки и возврат результата
        return argument_parser.parse_args()

    # Метод для инициализации настроек приложения
    def initialize_settings(self, config_path):
        """Инициализирует настройки приложения"""
        try:
            # Парсинг конфигурации из указанного файла
            self.settings = self.parser.parse_configuration(config_path)
            # Возврат True при успешной инициализации
            return True
        except Exception as e:
            # Обработка ошибок инициализации
            print(f"Ошибка инициализации: {e}")
            # Возврат False при ошибке
            return False

    # Метод для выполнения дополнительной валидации
    def perform_validation(self):
        """Выполняет дополнительную валидацию"""
        # Проверка что настройки были инициализированы
        if not self.settings:
            return False

        try:
            # Дополнительная проверка согласованности параметров
            self._validate_consistency()
            print("Настройки прошли валидацию")
            # Возврат True при успешной валидации
            return True
        except Exception as e:
            # Обработка ошибок валидации
            print(f"Ошибка валидации: {e}")
            # Возврат False при ошибке валидации
            return False

    # Внутренний метод для проверки согласованности параметров
    def _validate_consistency(self):
        """Проверяет согласованность параметров конфигурации"""
        # Проверка что для тестового режима указан корректный путь
        if self.settings['test_mode'] in ['true', 'enabled']:
            repo_url = self.settings['repository_url']
            if not repo_url.startswith(('file://', '/')):
                print("Предупреждение: В тестовом режиме рекомендуется использовать локальные файлы")

        # Проверка что глубина анализа разумная
        if self.settings['max_depth'] > 10:
            print("Предупреждение: Большая глубина анализа может замедлить работу")

    # Метод для отображения текущей конфигурации
    def display_current_configuration(self):
        """Отображает текущую конфигурацию"""
        # Проверка что настройки существуют
        if not self.settings:
            return

        # Вывод заголовка конфигурации
        print("ТЕКУЩАЯ КОНФИГУРАЦИЯ СИСТЕМЫ")

        # Словарь для преобразования технических имен в читаемые описания
        display_map = {
            'package_name': 'Анализируемый пакет',
            'package_version': 'Версия пакета',
            'output_filename': 'Выходной файл',
            'ascii_tree_mode': 'Режим ASCII-дерева',
            'max_depth': 'Максимальная глубина',
            'repository_url': 'URL репозитория',
            'test_mode': 'Режим тестирования'
        }

        # Цикл по всем элементам словаря для отображения
        for key, description in display_map.items():
            # Получение значения или заглушки если значение отсутствует
            value = self.settings.get(key, 'Не указано')
            # Форматированный вывод параметра
            print(f"  {description:<25} : {value}")

        # Закрывающая линия

    # Основной метод выполнения приложения
    def execute_application(self):
        """Запускает основную логику приложения"""
        # Обработка аргументов командной строки
        args = self.process_arguments()

        # Сообщение о запуске системы
        print("Запуск системы анализа зависимостей...")

        # Загрузка настроек из файла
        if not self.initialize_settings(args.config):
            return 1  # Код ошибки при неудачной загрузке

        # Выполнение валидации настроек
        if not self.perform_validation():
            return 1  # Код ошибки при неудачной валидации

        # Проверка режима проверки (без выполнения основного функционала)
        if args.verify:
            print("Режим проверки активирован")
            return 0  # Успешное завершение в режиме проверки

        # Отображение текущей конфигурации
        self.display_current_configuration()

        # Успешное завершение работы
        return 0


# Главная функция - точка входа в приложение
def main():
    """Точка входа"""
    # Создание экземпляра ядра приложения
    app = ApplicationCore()
    # Запуск приложения и возврат кода завершения
    return app.execute_application()


# Стандартная проверка для прямого запуска скрипта
if __name__ == "__main__":
    # Запуск приложения и выход с соответствующим кодом
    sys.exit(main())